from typing import List


# этот класс будет содержать методы, реализующие алгоритмы поиска в различных структурах данных
class Search_Algorithms:
    # метод для поиска заданного числа в отсортированном списке целых чисел
    # метод возвращает индекс искомого числа, как если бы оно входило в список
    # либо индекс самого числа, если оно входит в состав исходного списка
    # пример_1 [1, 2, 4, 5], 3 --> [1, 2, {3}, 4, 5] (метод возвращает 2, индекс числа 3 и исходном списке)
    # пример_2 [3], 4 --> [3, {4}] (метод возвращает 1, индекс числа 4, мысленно подставленного в список)
    def binary_search_insert_num_in_list(self, nums: List[int], target: int) -> int:
        # необходимо инициализировать начальный и конечный индексы для прербора
        begin = 0
        end = len(nums) - 1
        # условие цикла - равенство "конца" и "начала"
        while begin <= end:
            # находим текущий "индекс середины" списка
            # момент: сумму делим нацело, так как это индекс, а он должен быть int
            mid_index = (begin + end) // 2
            # первое условие, яснее некуда - если искомое=элемент[середины], верни его(индекс)
            if target == nums[mid_index]:
                return mid_index
            # далее два условия сдвига диапазона поиска влево или вправо по списку
            # первое: если искомое число больше элемента[середины],
            # назначаем новое "начало" списка, сдвигаемся вправо на +1 от текущей середины
            # "конец" остается тот же
            elif target > nums[mid_index]:
                # ВАЖНО!!! именно из за того, что при этом условии приравниваем "начало"
                # к "середине" + 1, в конце метод возвращает "начало"
                begin = mid_index + 1
                # второе: если искомое число меньше лемента[середины],
            # назначаем новый "конец" списка, сдвигаем влево на -1 от текущей середины
            else:
                end = mid_index - 1
            # продолжаем, пока не выяснится, где расположено искомое число в списке

        # условие ниже - вариант, если при сдвиге вправо дошли до случая, когда искомое число
        # расположено левее списка[0], ставим его перед первым элементом текущего списка
        # и возвращаем 0, так как искомое число "стоит" на первом месте списка
        if begin == 0:
            return 0
        # во всех других случаях - возвращаем получившееся "начало"
        # (см. комментарий к строке 30 (номер строки может меняться, begin = mid_index + 1))
        else:
            return begin

